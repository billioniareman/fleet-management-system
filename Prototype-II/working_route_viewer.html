<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Working Route Viewer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; width: 100%; }
        .controls { position: absolute; top: 10px; left: 10px; z-index: 1000; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .legend { margin-top: 10px; }
        .legend-item { display: inline-block; margin-right: 15px; font-size: 12px; }
        .legend-color { width: 12px; height: 12px; display: inline-block; margin-right: 5px; border-radius: 2px; }
        .status { margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Route Viewer</h3>
        <button onclick="loadRoutes()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Load Routes</button>
        <button onclick="loadStepRoutes()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">Load Step Routes</button>
        <button onclick="testCoordinateOrder()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">Test Coord Order</button>
        <div class="legend">
            <div class="legend-item"><span class="legend-color" style="background: #1f77b4;"></span>Route 1</div>
            <div class="legend-item"><span class="legend-color" style="background: #ff7f0e;"></span>Route 2</div>
            <div class="legend-item"><span class="legend-color" style="background: #2ca02c;"></span>Route 3</div>
            <div class="legend-item"><span class="legend-color" style="background: #d62728;"></span>Route 4</div>
        </div>
        <div class="status" id="status">Ready to load routes...</div>
    </div>
    <div id="map"></div>

    <script>
        // Initialize map centered on South Africa
        const map = L.map('map').setView([-26.2041, 28.0473], 6);
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Route colors
        const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'];
        let routeLayers = [];
        let markerLayers = [];

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log(message);
        }

        // Decode NextBillion.ai polyline
        function decodePolyline(str) {
            if (!str || typeof str !== 'string') return [];
            let index = 0, lat = 0, lon = 0, coords = [];
            const factor = 1e6;
            
            while (index < str.length) {
                let result = 0, shift = 0, b;
                
                // Decode latitude
                do { 
                    b = str.charCodeAt(index++) - 63; 
                    result |= (b & 0x1f) << shift; 
                    shift += 5; 
                } while (b >= 0x20);
                
                const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
                lat += dlat;
                
                // Decode longitude
                result = 0; shift = 0;
                do { 
                    b = str.charCodeAt(index++) - 63; 
                    result |= (b & 0x1f) << shift; 
                    shift += 5; 
                } while (b >= 0x20);
                
                const dlon = (result & 1) ? ~(result >> 1) : (result >> 1);
                lon += dlon;
                
                // Try both coordinate orders to see which one is correct
                coords.push([lat / factor, lon / factor]); // [lat, lng] format
            }
            return coords;
        }

        // Alternative decoder that might have different coordinate order
        function decodePolylineAlternative(str) {
            if (!str || typeof str !== 'string') return [];
            let index = 0, lat = 0, lon = 0, coords = [];
            const factor = 1e6;
            
            while (index < str.length) {
                let result = 0, shift = 0, b;
                
                // Decode longitude first (alternative order)
                do { 
                    b = str.charCodeAt(index++) - 63; 
                    result |= (b & 0x1f) << shift; 
                    shift += 5; 
                } while (b >= 0x20);
                
                const dlon = (result & 1) ? ~(result >> 1) : (result >> 1);
                lon += dlon;
                
                // Decode latitude second
                result = 0; shift = 0;
                do { 
                    b = str.charCodeAt(index++) - 63; 
                    result |= (b & 0x1f) << shift; 
                    shift += 5; 
                } while (b >= 0x20);
                
                const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
                lat += dlat;
                
                coords.push([lat / factor, lon / factor]); // [lat, lng] format
            }
            return coords;
        }

        function clearMap() {
            // Clear existing routes and markers
            routeLayers.forEach(layer => map.removeLayer(layer));
            markerLayers.forEach(layer => map.removeLayer(layer));
            routeLayers = [];
            markerLayers = [];
        }

        async function loadRoutes() {
            try {
                clearMap();
                updateStatus('Loading routes...');
                
                // Try multiple ways to load the data
                let data = null;
                
                // Method 1: Try server endpoint first
                try {
                    const response = await fetch('http://127.0.0.1:8000/cases/1');
                    if (response.ok) {
                        data = await response.json();
                        updateStatus('Data loaded via server endpoint');
                        console.log('Data received:', data);
                    }
                } catch (e) {
                    console.log('Server endpoint failed, trying direct fetch...');
                }
                
                // Method 2: Try direct fetch
                if (!data) {
                    try {
                        const response = await fetch('cases/1/get.json');
                        if (response.ok) {
                            data = await response.json();
                            updateStatus('Data loaded via fetch');
                        }
                    } catch (e) {
                        console.log('Fetch failed, trying alternative...');
                    }
                }
                
                // Method 3: Use embedded sample data if all else fails
                if (!data) {
                    updateStatus('Using sample data - please load your get.json file');
                    // You can paste your JSON data here as a fallback
                    return;
                }
                
                console.log('Data loaded:', data);
                
                if (!data || !data.result) {
                    updateStatus('No valid data found in response');
                    return;
                }
                
                const routes = data.result.routes || [];
                const unassigned = data.result.unassigned || [];
                
                updateStatus(`Found ${routes.length} routes and ${unassigned.length} unassigned jobs`);
                console.log('Routes found:', routes.length);
                console.log('Unassigned found:', unassigned.length);
                
                let allBounds = [];
                
                // Process each route
                routes.forEach((route, idx) => {
                    console.log(`Processing route ${idx}:`, route.vehicle);
                    console.log('Route geometry type:', typeof route.geometry);
                    console.log('Route geometry length:', route.geometry ? route.geometry.length : 'none');
                    console.log('Route steps count:', route.steps ? route.steps.length : 'none');
                    
                    // Decode geometry
                    let coords = [];
                    if (route.geometry && typeof route.geometry === 'string') {
                        console.log('Decoding polyline geometry...');
                        coords = decodePolyline(route.geometry);
                        console.log(`Decoded ${coords.length} points for route ${idx}`);
                        if (coords.length > 0) {
                            console.log('First few coordinates:', coords.slice(0, 3));
                            // Check if coordinates look reasonable for South Africa
                            const firstCoord = coords[0];
                            console.log('First coordinate:', firstCoord);
                            console.log('Lat range check:', firstCoord[0] >= -35 && firstCoord[0] <= -22);
                            console.log('Lng range check:', firstCoord[1] >= 16 && firstCoord[1] <= 33);
                        }
                    }
                    
                    // If no geometry, use steps
                    if (coords.length === 0 && route.steps) {
                        console.log('Using step coordinates...');
                        coords = route.steps
                            .map(step => {
                                const loc = step.snapped_location || step.location;
                                return loc ? [loc[0], loc[1]] : null;
                            })
                            .filter(Boolean);
                        console.log(`Using ${coords.length} step coordinates for route ${idx}`);
                        if (coords.length > 0) {
                            console.log('First step coordinate:', coords[0]);
                        }
                    }
                    
                    // Compare geometry coords with step coords if both exist
                    if (coords.length > 0 && route.steps && route.steps.length > 0) {
                        const firstStep = route.steps[0];
                        const stepLoc = firstStep.snapped_location || firstStep.location;
                        if (stepLoc) {
                            console.log('First step location:', stepLoc);
                            console.log('First geometry coord:', coords[0]);
                            console.log('Coordinate difference:', {
                                lat: Math.abs(coords[0][0] - stepLoc[0]),
                                lng: Math.abs(coords[0][1] - stepLoc[1])
                            });
                        }
                    }
                    
                    // Draw route line
                    if (coords.length > 1) {
                        console.log(`Drawing route ${idx} with ${coords.length} coordinates`);
                        const polyline = L.polyline(coords, {
                            color: colors[idx % colors.length],
                            weight: 4,
                            opacity: 0.8
                        }).addTo(map);
                        routeLayers.push(polyline);
                        
                        // Add to bounds
                        coords.forEach(coord => allBounds.push(coord));
                        
                        console.log(`Route ${idx} drawn successfully`);
                    } else {
                        console.log(`Route ${idx} has insufficient coordinates: ${coords.length}`);
                    }
                    
                    // Add markers for steps
                    if (route.steps) {
                        route.steps.forEach((step, stepIdx) => {
                            const loc = step.snapped_location || step.location;
                            if (loc) {
                                const marker = L.marker([loc[0], loc[1]])
                                    .bindPopup(`
                                        <b>${step.type || 'Stop'}</b><br>
                                        ${step.id || ''}<br>
                                        ${route.vehicle || 'Vehicle'}<br>
                                        Step ${stepIdx + 1}
                                    `)
                                    .addTo(map);
                                markerLayers.push(marker);
                                allBounds.push([loc[0], loc[1]]);
                            }
                        });
                    }
                });
                
                // Add unassigned markers
                unassigned.forEach((job, idx) => {
                    if (job.location) {
                        const marker = L.marker([job.location[0], job.location[1]])
                            .bindPopup(`
                                <b>Unassigned</b><br>
                                ${job.id || ''}<br>
                                ${job.type || ''}<br>
                                ${job.reason || ''}
                            `)
                            .addTo(map);
                        markerLayers.push(marker);
                        allBounds.push([job.location[0], job.location[1]]);
                    }
                });
                
                // Fit map to show all routes
                if (allBounds.length > 0) {
                    const group = new L.featureGroup(routeLayers.concat(markerLayers));
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                updateStatus(`Map updated with ${routeLayers.length} routes and ${markerLayers.length} markers`);
                
            } catch (error) {
                console.error('Error loading routes:', error);
                updateStatus('Error loading routes. Check console for details.');
            }
        }

        // Function to load routes using only step coordinates
        async function loadStepRoutes() {
            try {
                clearMap();
                updateStatus('Loading step-based routes...');
                
                // Load data
                const response = await fetch('http://127.0.0.1:8000/cases/1');
                if (!response.ok) throw new Error('Failed to fetch data');
                const data = await response.json();
                
                const routes = data.result.routes || [];
                const unassigned = data.result.unassigned || [];
                
                updateStatus(`Found ${routes.length} routes - using step coordinates only`);
                
                let allBounds = [];
                
                // Process each route using only step coordinates
                routes.forEach((route, idx) => {
                    console.log(`Processing step route ${idx}:`, route.vehicle);
                    
                    if (route.steps) {
                        const coords = route.steps
                            .map(step => {
                                const loc = step.snapped_location || step.location;
                                return loc ? [loc[0], loc[1]] : null;
                            })
                            .filter(Boolean);
                        
                        console.log(`Step route ${idx} has ${coords.length} coordinates`);
                        
                        if (coords.length > 1) {
                            const polyline = L.polyline(coords, {
                                color: colors[idx % colors.length],
                                weight: 3,
                                opacity: 0.6,
                                dashArray: '5, 5' // Dashed line to distinguish from geometry routes
                            }).addTo(map);
                            routeLayers.push(polyline);
                            
                            coords.forEach(coord => allBounds.push(coord));
                            console.log(`Step route ${idx} drawn with ${coords.length} points`);
                        }
                    }
                });
                
                // Add markers
                routes.forEach((route, idx) => {
                    if (route.steps) {
                        route.steps.forEach((step, stepIdx) => {
                            const loc = step.snapped_location || step.location;
                            if (loc) {
                                const marker = L.marker([loc[0], loc[1]])
                                    .bindPopup(`
                                        <b>${step.type || 'Stop'}</b><br>
                                        ${step.id || ''}<br>
                                        ${route.vehicle || 'Vehicle'}<br>
                                        Step ${stepIdx + 1}
                                    `)
                                    .addTo(map);
                                markerLayers.push(marker);
                                allBounds.push([loc[0], loc[1]]);
                            }
                        });
                    }
                });
                
                // Add unassigned markers
                unassigned.forEach((job, idx) => {
                    if (job.location) {
                        const marker = L.marker([job.location[0], job.location[1]])
                            .bindPopup(`
                                <b>Unassigned</b><br>
                                ${job.id || ''}<br>
                                ${job.type || ''}<br>
                                ${job.reason || ''}
                            `)
                            .addTo(map);
                        markerLayers.push(marker);
                        allBounds.push([job.location[0], job.location[1]]);
                    }
                });
                
                // Fit map
                if (allBounds.length > 0) {
                    const group = new L.featureGroup(routeLayers.concat(markerLayers));
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                updateStatus(`Step routes loaded: ${routeLayers.length} routes, ${markerLayers.length} markers`);
                
            } catch (error) {
                console.error('Error loading step routes:', error);
                updateStatus('Error loading step routes');
            }
        }

        // Function to test both coordinate orders
        async function testCoordinateOrder() {
            try {
                clearMap();
                updateStatus('Testing coordinate orders...');
                
                // Load data
                const response = await fetch('http://127.0.0.1:8000/cases/1');
                if (!response.ok) throw new Error('Failed to fetch data');
                const data = await response.json();
                
                const routes = data.result.routes || [];
                const unassigned = data.result.unassigned || [];
                
                updateStatus(`Testing ${routes.length} routes with both coordinate orders`);
                
                let allBounds = [];
                
                // Process first route with both coordinate orders
                if (routes.length > 0) {
                    const route = routes[0];
                    console.log('Testing route 0:', route.vehicle);
                    
                    if (route.geometry && typeof route.geometry === 'string') {
                        // Test original order (lat first, then lng)
                        const coords1 = decodePolyline(route.geometry);
                        console.log('Original order - first 3 coords:', coords1.slice(0, 3));
                        
                        // Test alternative order (lng first, then lat)
                        const coords2 = decodePolylineAlternative(route.geometry);
                        console.log('Alternative order - first 3 coords:', coords2.slice(0, 3));
                        
                        // Compare with step coordinates
                        if (route.steps && route.steps.length > 0) {
                            const stepCoords = route.steps
                                .map(step => {
                                    const loc = step.snapped_location || step.location;
                                    return loc ? [loc[0], loc[1]] : null;
                                })
                                .filter(Boolean);
                            
                            console.log('Step coordinates - first 3:', stepCoords.slice(0, 3));
                            
                            // Calculate distances to see which is closer
                            if (coords1.length > 0 && coords2.length > 0 && stepCoords.length > 0) {
                                const dist1 = Math.abs(coords1[0][0] - stepCoords[0][0]) + Math.abs(coords1[0][1] - stepCoords[0][1]);
                                const dist2 = Math.abs(coords2[0][0] - stepCoords[0][0]) + Math.abs(coords2[0][1] - stepCoords[0][1]);
                                
                                console.log('Distance to step coords - Original:', dist1, 'Alternative:', dist2);
                                
                                // Draw both versions with different styles
                                if (coords1.length > 1) {
                                    const polyline1 = L.polyline(coords1, {
                                        color: '#1f77b4',
                                        weight: 4,
                                        opacity: 0.8
                                    }).addTo(map);
                                    routeLayers.push(polyline1);
                                    coords1.forEach(coord => allBounds.push(coord));
                                }
                                
                                if (coords2.length > 1) {
                                    const polyline2 = L.polyline(coords2, {
                                        color: '#ff7f0e',
                                        weight: 4,
                                        opacity: 0.8,
                                        dashArray: '10, 10'
                                    }).addTo(map);
                                    routeLayers.push(polyline2);
                                    coords2.forEach(coord => allBounds.push(coord));
                                }
                            }
                        }
                    }
                }
                
                // Add markers for comparison
                routes.forEach((route, idx) => {
                    if (route.steps) {
                        route.steps.forEach((step, stepIdx) => {
                            const loc = step.snapped_location || step.location;
                            if (loc) {
                                const marker = L.marker([loc[0], loc[1]])
                                    .bindPopup(`
                                        <b>${step.type || 'Stop'}</b><br>
                                        ${step.id || ''}<br>
                                        ${route.vehicle || 'Vehicle'}<br>
                                        Step ${stepIdx + 1}
                                    `)
                                    .addTo(map);
                                markerLayers.push(marker);
                                allBounds.push([loc[0], loc[1]]);
                            }
                        });
                    }
                });
                
                // Add unassigned markers
                unassigned.forEach((job, idx) => {
                    if (job.location) {
                        const marker = L.marker([job.location[0], job.location[1]])
                            .bindPopup(`
                                <b>Unassigned</b><br>
                                ${job.id || ''}<br>
                                ${job.type || ''}<br>
                                ${job.reason || ''}
                            `)
                            .addTo(map);
                        markerLayers.push(marker);
                        allBounds.push([job.location[0], job.location[1]]);
                    }
                });
                
                // Fit map
                if (allBounds.length > 0) {
                    const group = new L.featureGroup(routeLayers.concat(markerLayers));
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                updateStatus('Coordinate test complete - Blue=solid (original), Orange=dashed (alternative)');
                
            } catch (error) {
                console.error('Error testing coordinates:', error);
                updateStatus('Error testing coordinates');
            }
        }

        // Auto-load routes when page loads
        window.addEventListener('load', () => {
            console.log('Page loaded, auto-loading routes...');
            loadRoutes();
        });
    </script>
</body>
</html>
